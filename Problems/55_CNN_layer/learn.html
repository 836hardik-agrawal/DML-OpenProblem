<h2>Understanding Convolutional Neural Networks (CNNs)</h2>
<p>Convolutional Neural Networks are a class of deep neural networks primarily used for processing data with a grid-like topology, such as images. They are designed to automatically and adaptively learn spatial hierarchies of features through backpropagation by using multiple building blocks, such as convolution layers, pooling layers, and fully connected layers.</p>

<h3>Mathematical Formulation</h3>
<p>A CNN layer applies a convolution operation to the input, passing the result to the next layer. The convolution operation involves a filter or kernel that is convolved with the input data, possibly using padding and stride to control the spatial dimensions of the output.</p>

<p>For a single input channel and a single filter, the output \( y \) at position \( (i, j) \) is computed as:</p>

<p>
\[ y_{i,j} = \sum_{m=0}^{k-1} \sum_{n=0}^{k-1} x_{i \cdot s + m - p, \, j \cdot s + n - p} \cdot w_{m,n} + b \]
</p>

<p>Where:</p>
<ul>
    <li>\( x \) is the input matrix (e.g., image pixels).</li>
    <li>\( w \) is the filter (kernel) of size \( k \times k \).</li>
    <li>\( b \) is the bias term.</li>
    <li>\( s \) is the stride (step size of the filter movement).</li>
    <li>\( p \) is the padding size (number of pixels added to the border of the input).</li>
    <li>The indices \( i \) and \( j \) iterate over the spatial dimensions of the output feature map.</li>
    <li>The expression \( x_{i \cdot s + m - p, \, j \cdot s + n - p} \) handles the stride and padding.</li>
</ul>

<h3>Implementation Steps</h3>
<ol>
    <li><strong>Initialization</strong>:
        <ul>
            <li>Define the filter weights \( w \) and bias \( b \).</li>
            <li>Specify the stride \( s \) and padding \( p \).</li>
        </ul>
    </li>
    <li><strong>Input Padding</strong>:
        <ul>
            <li>Pad the input matrix \( x \) with zeros around the border to maintain spatial dimensions.</li>
        </ul>
    </li>
    <li><strong>Convolution Operation</strong>:
        <ul>
            <li>Slide the filter over the input data using the specified stride.</li>
            <li>At each position, compute the element-wise multiplication between the filter and the corresponding input patch.</li>
            <li>Sum all the multiplied values and add the bias.</li>
        </ul>
    </li>
    <li><strong>Activation Function</strong>:
        <ul>
            <li>Apply an activation function (e.g., ReLU) to introduce non-linearity.</li>
        </ul>
    </li>
</ol>

<h3>Example Calculation with Padding and Stride</h3>
<p><strong>Given:</strong></p>
<ul>
    <li>Input matrix \( x \)  ( 3x3 image):
        \[
        x = \begin{bmatrix}
        1 & 2 & 0 \\
        0 & 1 & 2 \\
        2 & 1 & 0
        \end{bmatrix}
        \]
    </li>
    <li>Filter \( w \) ( 2x2 kernel):
        \[
        w = \begin{bmatrix}
        1 & 0 \\
        0 & -1
        \end{bmatrix}
        \]
    </li>
    <li>Bias \( b = 0 \)</li>
    <li>Stride \( s = 1 \)</li>
    <li>Padding \( p = 1 \)</li>
    <li>Activation function: None (for simplicity)</li>
</ul>

<p><strong>Compute:</strong></p>

<ol>
    <li><strong>Input Padding:</strong>
        <p>Pad the input matrix with zeros (padding size \( p = 1 \)):</p>
        \[
        x_{\text{padded}} = \begin{bmatrix}
        0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 2 & 0 & 0 \\
        0 & 0 & 1 & 2 & 0 \\
        0 & 2 & 1 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        \end{bmatrix}
        \]
    </li>

    <li><strong>Calculate Output Dimensions:</strong>
        <p>The output dimensions are computed as:</p>
        \[
        \text{Output Height} = \left\lfloor \frac{\text{Input Height} + 2p - k}{s} \right\rfloor + 1 = \left\lfloor \frac{5 + 2 \times 0 - 2}{1} \right\rfloor + 1 = 4
        \]
        \[
        \text{Output Width} = \left\lfloor \frac{\text{Input Width} + 2p - k}{s} \right\rfloor + 1 = \left\lfloor \frac{5 + 2 \times 0 - 2}{1} \right\rfloor + 1 = 4
        \]
    </li>

    <li><strong>Perform Convolution:</strong>

        <p>We will compute each element of the output feature map \( y \) using the formula:</p>
        \[
        y_{i,j} = \sum_{m=0}^{1} \sum_{n=0}^{1} x_{i + m - p,\, j + n - p} \cdot w_{m,n}
        \]

        <p><strong>First position (\( i = 0, j = 0 \)):</strong></p>
        \[
        \begin{align*}
        y_{0,0} &= x_{0,0} \cdot w_{0,0} + x_{0,1} \cdot w_{0,1} + x_{1,0} \cdot w_{1,0} + x_{1,1} \cdot w_{1,1} \\
                &= (0 \times 1) + (0 \times 0) + (0 \times 0) + (1 \times -1) \\
                &= 0 + 0 + 0 - 1 = -1
        \end{align*}
        \]

        <p><strong>Second position (\( i = 0, j = 1 \)):</strong></p>
        \[
        \begin{align*}
        y_{0,1} &= x_{0,1} \cdot w_{0,0} + x_{0,2} \cdot w_{0,1} + x_{1,1} \cdot w_{1,0} + x_{1,2} \cdot w_{1,1} \\
                &= (0 \times 1) + (0 \times 0) + (1 \times 0) + (2 \times -1) \\
                &= 0 + 0 + 0 - 2 = -2
        \end{align*}
        \]

        <p>Continue this process for all positions \( (i, j) \) in the output feature map.</p>

    </li>

    <li><strong>Resulting Feature Map \( y \):</strong>
        \[
        y = \begin{bmatrix}
        -1 & -2 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        -2 & -1 & 1 & 2 \\
        0 & 2 & 1 & 0 \\
        \end{bmatrix}
        \]
    </li>
</ol>

<h3>Applications</h3>
<p>CNNs are extensively used in image and video recognition, recommender systems, image classification, medical image analysis, and natural language processing tasks where data can be represented in a grid-like structure.</p>
